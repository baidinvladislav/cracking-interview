<h1>Design a URL shortener</h1>


<h2>Определение масштаба проекта</h2>
Вопросы по дизайну систем намеренно оставляют открытыми, так что необходимо задававть уточняющие вопросы и принимать 
решения от ответов интервьюера, чтобы точно понимать его требования. 

Что мы строим и какой функционал нам необходим?

<b>Фичи:</b>
Нужно ли строить полное веб-приложение с пользовательским интерфейсом?
Нет, например, нам достаточно построить API нашего сервиса.

Нужна ли нам авторизация или аккаунты пользователей?
Нет, этим можно принебречь для старта.

Могут ли пользователи удалять или изменять ссылки?
Пока, что это тоже не нужно.

Если пользователи не могу удалять ссылки, то мы храним им всегда? Или же автоматически удаляем старые и неактуальные ссылки?
Оставим ссылки храниться вечно.

Следует ли нам давать возможность выбрать название короткой ссылки пользователям или работать всегда с автоматическм генерированием ссылок?
Да, нужно поддерживать ввод названия ссылки пользователем.

Нужно ли предоставлять аналитику пользователям, насчет того сколько кликают по их коротким ссылкам?
Пока что нам это не нужно, хотя, кажется, хорошим предложением для реализации в будущем.

<b>Следующий шаг: Определение целей дизайна</b>
Как сейчас мы представляем нашу систему:
1. Система должна хранить большое количество ссылок, поскольку мы их не удаляем автоматически по истечению срока годности.
2. Наши ссылки должны быть как можно короче.
3. Переход по ссылке должен быть быстр.
4. Система должна выдерживать скачки нагрузки по ссылкам, например нашу ссылку разместили на больших площадках, таких как Reddit.


<b>Следующий шаг: Построение модели данных</b>
Побеспокойся о нейминге своих сущностей. Это поможет яснее комуницировать с интервьюером, а также покажет, что ты беспокоишься
об описательных и ясных именах, большинство компаний ищут это в кандидатах.

Наша главная сущность:
```python
# Link
#  - short_link
#  - long_link
```

short_link - может быть представлено как и пользовательским именем, так и автосгенированным нами названием ссылки.
Так как нет необходимости хранить весь адрес в short_link, а можно хранить лишь URI, переименуем поля в slug.

```python
# Link
#  - slug
#  - long_link
```

long_link - теперь это название выглядит не описательно, изменим.

```python
# Link
#  - slug
#  - destination
```

ShortLink - более описательное название для нашей сущности:
```python
# ShortLink
#  - slug
#  - destination
```

Потрать время на то, чтобы тщательно назвать вещи с самого начала, это всегда впечатляет в интервью. 
Большая часть удобочитаемости кода зависит от того, насколько хорошо названы вещи!


<b>Следующий шаг: Набросок кода</b>
Пока опустим детали реализации и воспользуемся псевдокодом.
Думайте об этой части как о реализации первого наивного наброску дизайна, чтобы вы и ваш интервьюер могли прийти к единому мнению 
и иметь отправную точку для оптимизации. По мере продвижения могут всплывать вещи, которые явно являются «каверзными вопросами», 
которые необходимо обдумать. Не стесняйтесь пропускать их по ходу дела — просто сделайте заметку, чтобы вернуться к ним позже.

Наша главная цель здесь — придумать скелет, из которого можно начать строить вещи. 
Подумаем, какие эндпоинты/представления нам понадобятся и что каждый из них должен будет делать.

<b>Views/Pages/Endpoints</b>
Во-первых, создадим эндпоинт для создания коротких ссылок.
Поскольку мы создаем API, сделаем его в REST стиле, хорошее объяснение о том, что это здесь http://www.restapitutorial.com/lessons/restquicktips.html.

Обычно в REST эндпоинт для создания ShortLink должна быть названа в честь объекта, который мы создаем. 
Управление версиями API также является разумным решением. Итак, давайте поместим конечную точку нашего создания в ca.ke/api/v1/shortlink.

Для того, чтобы создать новую ссылку мы отправляем POST запрос на эндпоинт для создания.
POST запрос должен включать в себя один обязательный аргумент: <b>destination</b> куда наша короткая ссылка будет указывать.
Также необязательным аргументом является slug. Если slug не указан в запросе пользователя, то мы создадим его автоматически на нашей стороне.
Ответ будет представлять из себя созданную короткую ссылку, включая поля slug и destination.

```commandline
$ curl --data '{"destination": "interviewcake.com"}' https://ca.ke/api/v1/shortlink
{
  "slug": "ae8uFt",
  "destination": "interviewcake.com"
}
```

Наш эндпоинт может выглядить примерно так, псевдокод:
```python
  def shortlink(request):
    if request['method'] is not 'POST':
        return Response(501)  # HTTP 501 NOT IMPLEMENTED

    destination = request['data']['destination']
    if 'slug' in request['data']:
        # If they included a slug, use that
        slug = request['data']['slug']
    else:
        # Else, make them one
        slug = generate_random_slug()

    DB.insert({'slug': slug, 'destination': destination})

    response_body = { 'slug': slug }
    return Response(200, json.dumps(response_body))  # HTTP 200 OK

```

Конечно, мы еще не знаем как реализовать нашу ф-ию generate_random_slug(), это довольно сложный вопрос, нам нужно выяснить:
1. Больше возможных символов означает больше возможных случайных слагов, не делая наши короткие ссылки длиннее. Но какие символы разрешены в URL-адресах?
2. Как убедиться, что случайно сгенерированный слаг еще не использовался? Или, если есть такое столкновение, как мы с ним справимся?

Итак, давайте запишем эти вопросы, отложим их в сторону и вернемся к ним после того, как закончим набрасывать общую структуру нашего приложения.

Во-вторых, давайте сделаем способ следовать ShortLink. Ведь в этом весь смысл!
Наши сокращенные URL-адреса должны быть как можно короче. Итак, как упоминалось ранее, мы дадим им следующий формат: ca.ke/$slug.

Где $slug — это слаг (автоматически сгенерированный нами или указанный пользователем). Мы могли бы уточнить, что это конечная точка перенаправления, используя, например, такой формат, как ca.ke/r/$slug. Но это добавляет 2 драгоценных символа длины к URL-адресам коротких ссылок!

Одна потенциальная проблема здесь: если/когда мы создадим веб-приложение для нашего сервиса, 
нам понадобится какой-то способ отличить наши собственные страницы от коротких ссылок. Например, если мы хотим, 
чтобы страница «о нас» была на ca.ke/about, нашему бэкенду нужно будет знать, что «о» — это не просто слаг короткой ссылки. 
Фактически, мы можем захотеть «зарезервировать» или «заблокировать» короткие ссылки для страниц, которые, по нашему мнению, 
могут нам понадобиться, чтобы пользователи не захватили URL-адреса, которые нам могут понадобиться для нашего собственного сайта. 
В качестве альтернативы мы могли бы просто сказать, что наши страницы имеют пути, которые всегда начинаются с чего-то вроде /w/. 
Например, ca.ke/w/about.

Код для конечной точки перенаправления довольно прост:
```python
def redirect(request):
    destination = DB.get({'slug': request['path']})['destination']
    return Response(302, destination)

```

<b>Следующий шаг: Генерация slug'a:</b>
Вернемся к тем вопросам, которые мы придумали о slug'aх. Какой длины они должны быть, 
какие символы мы должны использовать и как мы должны обрабатывать коллизии слагов?

Примечание о методологии: наш стандартный процесс ответа на подобные вопросы часто состоит в том, 
чтобы «сделать разумное предположение, провести мозговой штурм потенциальных проблем и пересмотреть». 
Это нормально, но иногда кажется более организованным и впечатляющим сделать что-то вроде «мозгового штурма 
по поводу целей дизайна, а затем проектировать вокруг этих целей».

Давайте вернемся к целям дизайна, которые мы поставили ранее. 
Первые два имеют непосредственное отношение к этой проблеме:
1. Система должна хранить большое количество ссылок, поскольку мы их не удаляем автоматически по истечению срока годности.
2. Наши ссылки должны быть как можно короче.

Глядя на несколько примеров, мы можем быстро заметить, что чем больше символов мы разрешаем в наших коротких ссылках, 
тем больше разных коротких ссылок мы можем иметь, не делая наши короткие ссылки длиннее. 
В частности, если мы разрешаем c разных символов, для слагов длиной n символов мы имеем c^n н отличные возможности.

<b>Как мы пришли к этим рассчетам?</b>
Мы придумали несколько примеров и нашли закономерности. Рассмотрим пример, когда доступно только два уникальных символа для наших слагов:
'a' и 'b', сколько уникальных слагов мы сможем получить? 2 - 'a' и 'b'.
Сколько возможных двухзначных слагов можно получить? Рассмотрим, у нас 2 уникальных возможности для первого символа,
и для каждого из этих двух символов у нас есть 2 уникальной возможности для второго символа, в итоге 2х2 = 4, возможных слага.
Сколько уникальных трехзначных слагов можно составить из тех же символов? 2 уникальных символа для первого символа, 2 для второго и также 2 для третьего
итого 2х2х2=8 уникальных слагов.
Итого мы имеем 2^n уникальных слагов, где n - длина слага, при двух символах 'a' и 'b'.
Что если мы захотим использовать не только символы 'a' и 'b'? Тогда мы будем иметь c^n уникальных слагов, где c - это кол-во используемых нами символов.

Итак, если мы пытаемся разместить как можно больше слагов, нам следует использовать как можно больше символов.
Тогда нам нужно воспользоваться следующим планом:
1. Узнать сколько сколько максимум символов мы можем использовать для генерации слагов.
2. Определиться сколько уникальных ссылок мы хотим разместить.
3. Выяснить какой длины должны быть наши короткие ссылки, чтобы мы смогли удовлетворить требованиям в пункте 1 и 2.

Набросать такой процесс перед тем, как приступить к нему, очень впечатляет.
Он показывает организованное, методичное мышление. Всякий раз, когда вы не знаете, как действовать, 
сделайте шаг назад и попытайтесь описать процесс, чтобы добраться до сути вещей.
Ничего страшного, если вы в конечном итоге отклонитесь от своего плана — это все равно поможет вам организовать свое мышление.


<b>Какие символы мы использвовать в наших случайно сгенерированных слагах?</b>
Давайте подумаем какие у нас есть ограничения на множество символов для слага:
1. Мы можем использовать только символы, которые допустимы в URL.
2. Вероятно, нам следует выбирать только те символы, которые относительно легко набирать на клавиатуре. (Помните пример использования, о котором мы говорили, когда люди вводят ShortLink, который они читают с листа бумаги?)

Так какие символы допустимы в URL? Это нормально не знать ответа наизусть, но следует сказать интервьюеру, что ты знаешь как найти ответ.
Google или StackOverFlow - хороший ответ.

В URL допустимы буквенно-цифровые символы и спец. символы: "$-_.+!*'(),".

Что насчет регистра? Домен регистронезависимый: google.com и Google.com - будет перенаправлять на один адрес.
Но URI регистрозависимый, запросы по адресам parker.com/foo и parker.com/Foo запросят разные документы.
Так что мы будем использовать как буквы верхнего регистра, так и буквы нижнего регистра в наших слагах.

Итого множество допустимыз символов - это A-Z, a-z, 0-9, а также спец символы: "$-_.+!*'(),".
Для читаемости и удобства ручного ввода пользователями ссылки в ручную уберем из множества спец символы.

Напомним, что пользователь может сам указать слаг для короткой ссылки, в этом слуяае мы допустим использование спец символов.
Для автогенерации множество будет выглядить как: a-z, A-Z, и 0-9, значит: 26 + 26 + 10 = 62, а также + 10 спец символов в случае указание слага пользователем.

<b>Сколько уникальных слагов нам нужно?</b>
Точное кол-во слагов лучше уточнить у интервьюера, тебе могут предоставить выбор на свое усмотрение.
Нет правильного ответа, главное показать организованность мышления.

Вот один из способов получить приблизительную оценку: сколько новых слагов мы можем создать за напряженный день? 
Может 100000 в минуту? Трудно представить что-то большее. Это 100 000 * 60 * 24 это примерно равно 145 млн ссылок в день. 
52,5 млрд ссылок в год. Какое количество лет кажется «почти вечностью»? Я бы сказал 100. Так что это 5,2 триллиона слагов. 
Это кажется достаточно большим. Это в значительной степени зависит от точности нашей оценки в 100 000 в минуту. 
Но это, кажется, довольно разумный потолок, и намеренно высокий. Если мы сможем разместить такое количество слагов, 
мы ожидаем, что сможем эффективно раздавать случайные слаги бесконечно долго.


<b>Насколько короткими мы можем сделать наши слаги, сохраняя при этом достаточно различных возможностей?</b>
Вернемся к нашей формуле, которую мы вывели до этого. Где c-это символы, которые можно использовать, а n-это длина слага.
Мы решили использовать 62 уникальных символа для генерации. Получим уравнение 62^n = 5 трлн,
Используем логарифм для получения ответа, ответ будет равен примерно 7.09, другими словами при множестве в 62 уникальных
символа для получения 5 трлн уникальных коротких ссылок нам нужно использовать слаг длиной в 7 символов.

Хорошо, мы знаем символы, которые будем использовать для слагов. И мы знаем, сколько символов мы будем использовать.

<b>Как мы будем генерировать slug'и?:</b>
Мы можем просто использовать случайных выбор для каждого символа в слаге:
```python
def generate_random_slug():
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    num_chars = 7
    return ''.join([random.choice(alphabet) for _ in range(num_chars)])
```

Но как обеспечить уникальность слагов? Две общие стратегии:
1. Создать слаг заново, если мы уже создавали его
2. Скорректировать нашу стратегию генерации слагов, чтобы мы всегда получали только уникальные слаги.

Вторая стратегия будет более уместна, так как по мере роста количества слагов в нашей БД, количество одинаковых слагов будет расти.

<b>Использование базового преобразования для создания слагов</b>

