<h1>Design a URL shortener</h1>


<h2>Определение масштаба проекта</h2>
Вопросы по дизайну систем намеренно оставляют открытыми, так что необходимо задававть уточняющие вопросы и принимать 
решения от ответов интервьюера, чтобы точно понимать его требования. 

Что мы строим и какой функционал нам необходим?

<b>Фичи:</b>
Нужно ли строить полное веб-приложение с пользовательским интерфейсом?
Нет, например, нам достаточно построить API нашего сервиса.

Нужна ли нам авторизация или аккаунты пользователей?
Нет, этим можно принебречь для старта.

Могут ли пользователи удалять или изменять ссылки?
Пока, что это тоже не нужно.

Если пользователи не могу удалять ссылки, то мы храним им всегда? Или же автоматически удаляем старые и неактуальные ссылки?
Оставим ссылки храниться вечно.

Следует ли нам давать возможность выбрать название короткой ссылки пользователям или работать всегда с автоматическм генерированием ссылок?
Да, нужно поддерживать ввод названия ссылки пользователем.

Нужно ли предоставлять аналитику пользователям, насчет того сколько кликают по их коротким ссылкам?
Пока что нам это не нужно, хотя, кажется, хорошим предложением для реализации в будущем.

<b>Следующий шаг: Определение целей дизайна</b>
Как сейчас мы представляем нашу систему:
1. Система должна хранить большое количество ссылок, поскольку мы их не удаляем автоматически по истечению срока годности.
2. Наши ссылки должны быть как можно короче.
3. Переход по ссылке должен быть быстр.
4. Система должна выдерживать скачки нагрузки по ссылкам, например нашу ссылку разместили на больших площадках, таких как Reddit.


<b>Следующий шаг: Построение модели данных</b>
Побеспокойся о нейминге своих сущностей. Это поможет яснее комуницировать с интервьюером, а также покажет, что ты беспокоишься
об описательных и ясных именах, большинство компаний ищут это в кандидатах.

Наша главная сущность:
```python
# Link
#  - short_link
#  - long_link
```

short_link - может быть представлено как и пользовательским именем, так и автосгенированным нами названием ссылки.
Так как нет необходимости хранить весь адрес в short_link, а можно хранить лишь URI, переименуем поля в slug.

```python
# Link
#  - slug
#  - long_link
```

long_link - теперь это название выглядит не описательно, изменим.

```python
# Link
#  - slug
#  - destination
```

ShortLink - более описательное название для нашей сущности:
```python
# ShortLink
#  - slug
#  - destination
```

Потрать время на то, чтобы тщательно назвать вещи с самого начала, это всегда впечатляет в интервью. 
Большая часть удобочитаемости кода зависит от того, насколько хорошо названы вещи!


<b>Следующий шаг: Набросок кода</b>
Пока опустим детали реализации и воспользуемся псевдокодом.
Думайте об этой части как о реализации первого наивного наброску дизайна, чтобы вы и ваш интервьюер могли прийти к единому мнению 
и иметь отправную точку для оптимизации. По мере продвижения могут всплывать вещи, которые явно являются «каверзными вопросами», 
которые необходимо обдумать. Не стесняйтесь пропускать их по ходу дела — просто сделайте заметку, чтобы вернуться к ним позже.

Наша главная цель здесь — придумать скелет, из которого можно начать строить вещи. 
Подумаем, какие эндпоинты/представления нам понадобятся и что каждый из них должен будет делать.

<b>Views/Pages/Endpoints</b>
Во-первых, создадим эндпоинт для создания коротких ссылок.
Поскольку мы создаем API, сделаем его в REST стиле, хорошее объяснение о том, что это здесь http://www.restapitutorial.com/lessons/restquicktips.html.

Обычно в REST эндпоинт для создания ShortLink должна быть названа в честь объекта, который мы создаем. 
Управление версиями API также является разумным решением. Итак, давайте поместим конечную точку нашего создания в ca.ke/api/v1/shortlink.

Для того, чтобы создать новую ссылку мы отправляем POST запрос на эндпоинт для создания.
POST запрос должен включать в себя один обязательный аргумент: <b>destination</b> куда наша короткая ссылка будет указывать.
Также необязательным аргументом является slug. Если slug не указан в запросе пользователя, то мы создадим его автоматически на нашей стороне.
Ответ будет представлять из себя созданную короткую ссылку, включая поля slug и destination.

```commandline
$ curl --data '{"destination": "interviewcake.com"}' https://ca.ke/api/v1/shortlink
{
  "slug": "ae8uFt",
  "destination": "interviewcake.com"
}
```

Наш эндпоинт может выглядить примерно так, псевдокод:
```python
  def shortlink(request):
    if request['method'] is not 'POST':
        return Response(501)  # HTTP 501 NOT IMPLEMENTED

    destination = request['data']['destination']
    if 'slug' in request['data']:
        # If they included a slug, use that
        slug = request['data']['slug']
    else:
        # Else, make them one
        slug = generate_random_slug()

    DB.insert({'slug': slug, 'destination': destination})

    response_body = { 'slug': slug }
    return Response(200, json.dumps(response_body))  # HTTP 200 OK

```

Конечно, мы еще не знаем как реализовать нашу ф-ию generate_random_slug(), это довольно сложный вопрос, нам нужно выяснить:
1. Больше возможных символов означает больше возможных случайных слагов, не делая наши короткие ссылки длиннее. Но какие символы разрешены в URL-адресах?
2. Как убедиться, что случайно сгенерированный слаг еще не использовался? Или, если есть такое столкновение, как мы с ним справимся?

Итак, давайте запишем эти вопросы, отложим их в сторону и вернемся к ним после того, как закончим набрасывать общую структуру нашего приложения.

Во-вторых, давайте сделаем способ следовать ShortLink. Ведь в этом весь смысл!
Наши сокращенные URL-адреса должны быть как можно короче. Итак, как упоминалось ранее, мы дадим им следующий формат: ca.ke/$slug.

Где $slug — это слаг (автоматически сгенерированный нами или указанный пользователем). Мы могли бы уточнить, что это конечная точка перенаправления, используя, например, такой формат, как ca.ke/r/$slug. Но это добавляет 2 драгоценных символа длины к URL-адресам коротких ссылок!

Одна потенциальная проблема здесь: если/когда мы создадим веб-приложение для нашего сервиса, 
нам понадобится какой-то способ отличить наши собственные страницы от коротких ссылок. Например, если мы хотим, 
чтобы страница «о нас» была на ca.ke/about, нашему бэкенду нужно будет знать, что «о» — это не просто слаг короткой ссылки. 
Фактически, мы можем захотеть «зарезервировать» или «заблокировать» короткие ссылки для страниц, которые, по нашему мнению, 
могут нам понадобиться, чтобы пользователи не захватили URL-адреса, которые нам могут понадобиться для нашего собственного сайта. 
В качестве альтернативы мы могли бы просто сказать, что наши страницы имеют пути, которые всегда начинаются с чего-то вроде /w/. 
Например, ca.ke/w/about.

Код для конечной точки перенаправления довольно прост:
```python
def redirect(request):
    destination = DB.get({'slug': request['path']})['destination']
    return Response(302, destination)

```

<b>Следующий шаг: Генерация slug'a:</b>
Вернемся к тем вопросам, которые мы придумали о slug'aх. Какой длины они должны быть, какие символы мы должны использовать и как мы должны обрабатывать коллизии слагов?

