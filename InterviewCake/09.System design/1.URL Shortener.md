<h1>Design a URL shortener</h1>


<h2>Определение масштаба проекта</h2>
Вопросы по дизайну систем намеренно оставляют открытыми, так что необходимо задававть уточняющие вопросы и принимать 
решения от ответов интервьюера, чтобы точно понимать его требования. 

Что мы строим и какой функционал нам необходим?

<b>Фичи:</b>
Нужно ли строить полное веб-приложение с пользовательским интерфейсом?
Нет, например, нам достаточно построить API нашего сервиса.

Нужна ли нам авторизация или аккаунты пользователей?
Нет, этим можно принебречь для старта.

Могут ли пользователи удалять или изменять ссылки?
Пока, что это тоже не нужно.

Если пользователи не могу удалять ссылки, то мы храним им всегда? Или же автоматически удаляем старые и неактуальные ссылки?
Оставим ссылки храниться вечно.

Следует ли нам давать возможность выбрать название короткой ссылки пользователям или работать всегда с автоматическм генерированием ссылок?
Да, нужно поддерживать ввод названия ссылки пользователем.

Нужно ли предоставлять аналитику пользователям, насчет того сколько кликают по их коротким ссылкам?
Пока что нам это не нужно, хотя, кажется, хорошим предложением для реализации в будущем.

<b>Следующий шаг: Определение целей дизайна</b>
Как сейчас мы представляем нашу систему:
1. Система должна хранить большое количество ссылок, поскольку мы их не удаляем автоматически по истечению срока годности.
2. Наши ссылки должны быть как можно короче.
3. Переход по ссылке должен быть быстр.
4. Система должна выдерживать скачки нагрузки по ссылкам, например нашу ссылку разместили на больших площадках, таких как Reddit.


<b>Следующий шаг: Построение модели данных</b>
Побеспокойся о нейминге своих сущностей. Это поможет яснее комуницировать с интервьюером, а также покажет, что ты беспокоишься
об описательных и ясных именах, большинство компаний ищут это в кандидатах.

Наша главная сущность:
```python
# Link
#  - short_link
#  - long_link
```

short_link - может быть представлено как и пользовательским именем, так и автосгенированным нами названием ссылки.
Так как нет необходимости хранить весь адрес в short_link, а можно хранить лишь URI, переименуем поля в slug.

```python
# Link
#  - slug
#  - long_link
```

long_link - теперь это название выглядит не описательно, изменим.

```python
# Link
#  - slug
#  - destination
```

ShortLink - более описательное название для нашей сущности:
```python
# ShortLink
#  - slug
#  - destination
```

Потрать время на то, чтобы тщательно назвать вещи с самого начала, это всегда впечатляет в интервью. 
Большая часть удобочитаемости кода зависит от того, насколько хорошо названы вещи!


<b>Следующий шаг: Набросок кода</b>
Пока опустим детали реализации и воспользуемся псевдокодом.
Думайте об этой части как о реализации первого наивного наброску дизайна, чтобы вы и ваш интервьюер могли прийти к единому мнению 
и иметь отправную точку для оптимизации. По мере продвижения могут всплывать вещи, которые явно являются «каверзными вопросами», 
которые необходимо обдумать. Не стесняйтесь пропускать их по ходу дела — просто сделайте заметку, чтобы вернуться к ним позже.

Наша главная цель здесь — придумать скелет, из которого можно начать строить вещи. 
Подумаем, какие эндпоинты/представления нам понадобятся и что каждый из них должен будет делать.

<b>Views/Pages/Endpoints</b>
Во-первых, создадим эндпоинт для создания коротких ссылок.
Поскольку мы создаем API, сделаем его в REST стиле, хорошее объяснение о том, что это здесь http://www.restapitutorial.com/lessons/restquicktips.html.

Обычно в REST эндпоинт для создания ShortLink должна быть названа в честь объекта, который мы создаем. 
Управление версиями API также является разумным решением. Итак, давайте поместим конечную точку нашего создания в ca.ke/api/v1/shortlink.

Для того, чтобы создать новую ссылку мы отправляем POST запрос на эндпоинт для создания.
POST запрос должен включать в себя один обязательный аргумент: <b>destination</b> куда наша короткая ссылка будет указывать.
Также необязательным аргументом является slug. Если slug не указан в запросе пользователя, то мы создадим его автоматически на нашей стороне.
Ответ будет представлять из себя созданную короткую ссылку, включая поля slug и destination.

```commandline
$ curl --data '{"destination": "interviewcake.com"}' https://ca.ke/api/v1/shortlink
{
  "slug": "ae8uFt",
  "destination": "interviewcake.com"
}
```

Наш эндпоинт может выглядить примерно так, псевдокод:
```python
  def shortlink(request):
    if request['method'] is not 'POST':
        return Response(501)  # HTTP 501 NOT IMPLEMENTED

    destination = request['data']['destination']
    if 'slug' in request['data']:
        # If they included a slug, use that
        slug = request['data']['slug']
    else:
        # Else, make them one
        slug = generate_random_slug()

    DB.insert({'slug': slug, 'destination': destination})

    response_body = { 'slug': slug }
    return Response(200, json.dumps(response_body))  # HTTP 200 OK

```

Конечно, мы еще не знаем как реализовать нашу ф-ию generate_random_slug(), это довольно сложный вопрос, нам нужно выяснить:
1. Больше возможных символов означает больше возможных случайных слагов, не делая наши короткие ссылки длиннее. Но какие символы разрешены в URL-адресах?
2. Как убедиться, что случайно сгенерированный слаг еще не использовался? Или, если есть такое столкновение, как мы с ним справимся?

Итак, давайте запишем эти вопросы, отложим их в сторону и вернемся к ним после того, как закончим набрасывать общую структуру нашего приложения.

Во-вторых, давайте сделаем способ следовать ShortLink. Ведь в этом весь смысл!
Наши сокращенные URL-адреса должны быть как можно короче. Итак, как упоминалось ранее, мы дадим им следующий формат: ca.ke/$slug.

Где $slug — это слаг (автоматически сгенерированный нами или указанный пользователем). Мы могли бы уточнить, что это конечная точка перенаправления, используя, например, такой формат, как ca.ke/r/$slug. Но это добавляет 2 драгоценных символа длины к URL-адресам коротких ссылок!

Одна потенциальная проблема здесь: если/когда мы создадим веб-приложение для нашего сервиса, 
нам понадобится какой-то способ отличить наши собственные страницы от коротких ссылок. Например, если мы хотим, 
чтобы страница «о нас» была на ca.ke/about, нашему бэкенду нужно будет знать, что «о» — это не просто слаг короткой ссылки. 
Фактически, мы можем захотеть «зарезервировать» или «заблокировать» короткие ссылки для страниц, которые, по нашему мнению, 
могут нам понадобиться, чтобы пользователи не захватили URL-адреса, которые нам могут понадобиться для нашего собственного сайта. 
В качестве альтернативы мы могли бы просто сказать, что наши страницы имеют пути, которые всегда начинаются с чего-то вроде /w/. 
Например, ca.ke/w/about.

Код для конечной точки перенаправления довольно прост:
```python
def redirect(request):
    destination = DB.get({'slug': request['path']})['destination']
    return Response(302, destination)

```

<b>Следующий шаг: Генерация slug'a:</b>
Вернемся к тем вопросам, которые мы придумали о slug'aх. Какой длины они должны быть, 
какие символы мы должны использовать и как мы должны обрабатывать коллизии слагов?

Примечание о методологии: наш стандартный процесс ответа на подобные вопросы часто состоит в том, 
чтобы «сделать разумное предположение, провести мозговой штурм потенциальных проблем и пересмотреть». 
Это нормально, но иногда кажется более организованным и впечатляющим сделать что-то вроде «мозгового штурма 
по поводу целей дизайна, а затем проектировать вокруг этих целей».

Давайте вернемся к целям дизайна, которые мы поставили ранее. 
Первые два имеют непосредственное отношение к этой проблеме:
1. Система должна хранить большое количество ссылок, поскольку мы их не удаляем автоматически по истечению срока годности.
2. Наши ссылки должны быть как можно короче.

Глядя на несколько примеров, мы можем быстро заметить, что чем больше символов мы разрешаем в наших коротких ссылках, 
тем больше разных коротких ссылок мы можем иметь, не делая наши короткие ссылки длиннее. 
В частности, если мы разрешаем c разных символов, для слагов длиной n символов мы имеем c^n отличные возможности.

<b>Как мы пришли к этим рассчетам?</b>
Мы придумали несколько примеров и нашли закономерности. Рассмотрим пример, когда доступно только два уникальных символа для наших слагов:
'a' и 'b', сколько уникальных слагов мы сможем получить? 2 - 'a' и 'b'.
Сколько возможных двухзначных слагов можно получить? Рассмотрим, у нас 2 уникальных возможности для первого символа,
и для каждого из этих двух символов у нас есть 2 уникальной возможности для второго символа, в итоге 2х2 = 4, возможных слага.
Сколько уникальных трехзначных слагов можно составить из тех же символов? 2 уникальных символа для первого символа, 2 для второго и также 2 для третьего
итого 2х2х2=8 уникальных слагов.
Итого мы имеем 2^n уникальных слагов, где n - длина слага, при двух символах 'a' и 'b'.
Что если мы захотим использовать не только символы 'a' и 'b'? Тогда мы будем иметь c^n уникальных слагов, где c - это кол-во используемых нами символов.

Итак, если мы пытаемся разместить как можно больше слагов, нам следует использовать как можно больше символов.
Тогда нам нужно воспользоваться следующим планом:
1. Узнать сколько максимум символов мы можем использовать для генерации слагов.
2. Определиться сколько уникальных ссылок мы хотим разместить.
3. Выяснить какой длины должны быть наши короткие ссылки, чтобы мы смогли удовлетворить требованиям в пункте 1 и 2.

Набросать такой процесс перед тем, как приступить к нему, очень впечатляет.
Он показывает организованное, методичное мышление. Всякий раз, когда вы не знаете, как действовать, 
сделайте шаг назад и попытайтесь описать процесс, чтобы добраться до сути вещей.
Ничего страшного, если вы в конечном итоге отклонитесь от своего плана — это все равно поможет вам организовать свое мышление.


<b>Какие символы мы можем использвовать в наших случайно сгенерированных слагах?</b>
Давайте подумаем какие у нас есть ограничения на множество символов для слага:
1. Мы можем использовать только символы, которые допустимы в URL.
2. Вероятно, нам следует выбирать только те символы, которые относительно легко набирать на клавиатуре. (Помните пример использования, о котором мы говорили, когда люди вводят ShortLink, который они читают с листа бумаги?)

Так какие символы допустимы в URL? Это нормально не знать ответа наизусть, но следует сказать интервьюеру, что ты знаешь как найти ответ.
Google или StackOverFlow - хороший ответ.

В URL допустимы буквенно-цифровые символы и спец. символы: "$-_.+!*'(),".

Что насчет регистра? Домен регистронезависимый: google.com и Google.com - будет перенаправлять на один адрес.
Но URI регистрозависимый, запросы по адресам parker.com/foo и parker.com/Foo запросят разные документы.
Так что мы будем использовать как буквы верхнего регистра, так и буквы нижнего регистра в наших слагах.

Итого множество допустимыз символов - это A-Z, a-z, 0-9, а также спец символы: "$-_.+!*'(),".
Для читаемости и удобства ручного ввода пользователями ссылки в ручную уберем из множества спец символы.

Напомним, что пользователь может сам указать слаг для короткой ссылки, в этом случае мы допустим использование спец символов.
Для автогенерации множество будет выглядить как: a-z, A-Z, и 0-9, значит: 26 + 26 + 10 = 62, а также + 10 спец символов в случае указание слага пользователем.

<b>Сколько уникальных слагов нам нужно?</b>
Точное кол-во слагов лучше уточнить у интервьюера, тебе могут предоставить выбор на свое усмотрение.
Нет правильного ответа, главное показать организованность мышления.

Вот один из способов получить приблизительную оценку: сколько новых слагов мы можем создать за напряженный день? 
Может 100000 в минуту? Трудно представить что-то большее. Это 100 000 * 60 * 24 это примерно равно 145 млн ссылок в день. 
52,5 млрд ссылок в год. Какое количество лет кажется «почти вечностью»? Я бы сказал 100. Так что это 5,2 триллиона слагов. 
Это кажется достаточно большим. Это в значительной степени зависит от точности нашей оценки в 100 000 в минуту. 
Но это, кажется, довольно разумный потолок, и намеренно высокий. Если мы сможем разместить такое количество слагов, 
мы ожидаем, что сможем эффективно раздавать случайные слаги бесконечно долго.


<b>Насколько короткими мы можем сделать наши слаги, сохраняя при этом достаточно различных возможностей?</b>
Вернемся к нашей формуле, которую мы вывели до этого. Где c-это символы, которые можно использовать, а n-это длина слага.
Мы решили использовать 62 уникальных символа для генерации. Получим уравнение 62^n = 5 трлн,
Используем логарифм для получения ответа, ответ будет равен примерно 7.09, другими словами при множестве в 62 уникальных
символа для получения 5 трлн уникальных коротких ссылок нам нужно использовать слаг длиной в 7 символов.

Хорошо, мы знаем символы, которые будем использовать для слагов. И мы знаем, сколько символов мы будем использовать.

<b>Как мы будем генерировать slug'и?:</b>
Мы можем просто использовать случайный выбор для каждого символа в слаге:
```python
def generate_random_slug():
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    num_chars = 7
    return ''.join([random.choice(alphabet) for _ in range(num_chars)])
```

Но как обеспечить уникальность слагов? Две общие стратегии:
1. Создать слаг заново, если мы уже создавали его
2. Скорректировать нашу стратегию генерации слагов, чтобы мы всегда получали только уникальные слаги.

Вторая стратегия будет более уместна, так как по мере роста количества слагов в нашей БД, количество одинаковых слагов будет расти.

<b>Использование базового преобразования для создания слагов</b>
Обычно мы используем десятичную систему исчисления: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
Бинарная система исчесления: 0 и 1.
Наш возможный алфавит для генерации состоит из 62 символов и позволяет представить его в 62 значной системе исчесления.
Мы можем отслеживать глобальный current_random_slug_id. Когда мы получаем запрос на создание нового слага, мы просто конвертируем 
это число в base-62 (используя наш собственный набор чисел) и возвращаем его. Также мы инкрементируем current_random_slug_id, готовясь к следующему запросу случайного слага.

```python
def generate_random_slug():
    global current_random_slug_id
    slug = base_conversion(current_random_slug_id, base_62_alphabet)
    current_random_slug_id += 1
    return slug
```

Где мы должны хранить наш current_random_slug_id? Мы можем сохранить его в памяти на нашем веб-сервере, 
возможно, с регулярной записью в базу данных, чтобы сделать его постоянным даже в случае сбоя веб-сервера. 
Но что, если у нас есть несколько интерфейсных веб-серверов?

Как мы делаем базовое преобразование? Это проще всего показать на примере.

Пердставим число 125 в 10 значной системе исчисления.
125 имеет 1 в разряде сотен, 2 в разаряде десятков и 5 в разряде единиц.

Таким образом, чтобы преобразовать 125 в base-62, мы распределяем эти 125 по этим base-62 «местам». 
Высшее «место», которое может занять кто-то это — 62^1 , то есть 62. 125/62 равно 2 с остатком 1. 
Таким образом, мы ставим 2 на место 62 и 1 на место 1. Итак, наш ответ 21.

А как насчет большего числа, скажем, 7912?

Теперь у нас достаточно, чтобы поставить что-то на место 3844 (62^262). 2 место). 
7 912 / 3 844 — это 2 с остатком 224. Поэтому мы ставим 2 на место 3 844 и 
распределяем оставшиеся 224 по оставшимся местам — месту 62 и месту 1. 224/62 равно 3 с остатком 38. 
Таким образом, мы ставим 3 на место 62 и 38 на место 1. У нас есть это трехзначное число: 2 3 38.
Итак, это «38» представляет одну цифру в нашем числе с основанием 62. Итак, 
нам нужно преобразовать эти 38 в конкретный выбор из нашего набора цифр: az, AZ и 0-9.

```python
map = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    # ...
    10: 'a',
    11: 'b',
    12: 'c',
    # ...
    36: 'A',
    37: 'B',
    38: 'C',
    # ...
    61: 'Z'
}
```

Как видите, наша «38-я» цифра — «С». Итак, мы конвертируем эти 38 в «C». Это дает нам 23C для 7912 в 62 значной системе исчесления.
Можем ли мы преобразовать слаги обратно в числа? Ага, легко. Возьмем, к примеру, 23С. Переведем числа обратно в их идентификационные номера, 
так что мы получим 2 3 38. Это 2 на месте 3844, поэтому мы берем 2 * 3844. Это 3 на месте 62, поэтому мы берем 3 * 62. 
Это 38 находится в 1 место, поэтому мы берем 38 * 1. Мы складываем все эти результаты, чтобы получить наши исходные 7912.

Одна потенциальная проблема: current_random_slug_id может быть короче 7 цифр в base-62. Мы могли бы дополнить генерируемый слаг нулями, 
чтобы он состоял ровно из 7 символов. Или мы могли бы просто принять более короткие случайные слаги — нам просто нужно убедиться, 
что наша функция, которая преобразует слаги обратно в числа, не захлебывается, когда слаг содержит менее 7 символов.

Другая проблема заключается в том, что current_random_slug_id может дать нам что-то, что пользователь уже заявил 
как созданный пользователем слаг. Нам нужно будет проверить это, и если это произойдет, мы просто увеличим current_random_slug_id 
и повторим попытку (и, возможно, снова, пока не столкнемся со «случайным» слагом, который еще не использовался).

```python
def generate_random_slug():
    global current_random_slug_id
    while True:
        slug = base_conversion(current_random_slug_id, base_62_alphabet)
        current_random_slug_id += 1
        # Make sure the slug isn't already used
        existing = DB.get({'slug': slug})
        if not existing:
            return slug

```

Хорошо, это сработает! Что дальше? Давайте вернемся к нашим целям дизайна!
1. Мы должны иметь возможность хранить много ссылок. 
2. Наши короткие ссылки должны быть как можно короче. 
3. Переход по короткой ссылке должен быть быстрым. 
4. Подписчик коротких ссылок должен быть устойчивым к скачкам нагрузки.

Мы выполнили 1 и 2! Давайте начнем решать 3 и 4. Как мы масштабируем нашего следящего за ссылками, 
чтобы он был быстрым и устойчивым к скачкам нагрузки?

Остерегайтесь преждевременной оптимизации! Это всегда выглядит плохо. Не перепрыгивайте через случайные идеи по оптимизации. 
Вместо этого сконцентрируйтесь на том, чтобы спросить себя, что в первую очередь является узким местом, и оптимизируйте его.

База данных, использующаяся для получения destination для данного слага, безусловно, будет нашим первым узким местом. 
Как правило, операции с базами данных обычно являются узким местом перед бизнес-логикой.

Чтобы выяснить, как сделать эти чтения быстрыми, мы должны уточнить, как мы храним наши короткие ссылки. 
Для начала, какую базу данных мы должны использовать?

В широком смысле (это определенно упрощение) в наши дни существует два основных типа баз данных:
1. Реляционные базы данных, такие как MySQL и Postgres.
2. NoSQL базы данных, такие как BigTable и Cassandra.

В целом (опять же, это упрощение) реляционные базы данных отлично подходят для систем, в которых предполагается 
выполнять множество сложных запросов, включающих соединения. Другими словами, они хороши, если вы планируете создавать связи между сущностями. 
Базы данных NoSQL не справляются с такими задачами, но взамен они быстрее выполняют запись и простое чтение по ключу-значению.

Глядя на наше приложение, кажется, что реляционные запросы вряд ли будут большой частью функциональности нашего приложения, 
даже если мы добавим несколько очевидных следующих функций, которые нам могут понадобиться. Так что давайте использовать NoSQL для этого.

Итак, у нас есть данные в базе данных типа NoSQL. Как мы устраняем узкие места при чтении базы данных?
Первый шаг — убедиться, что мы правильно индексируем. В контексте NoSQL это означает тщательное проектирование наших ключей. 
В этом случае очевидный выбор правильный: сделать ключ для каждой строки в таблице ShortLink нашим слагом.

Если мы использовали базу данных типа SQL, такую как MySQL или Postgres, мы обычно по умолчанию используем наше ключевое поле 
как стандартное целое число с автоинкрементом, называемое «id» или «index». Но в этом случае, поскольку мы знаем, что слаги будут уникальными, 
нет необходимости в целочисленном идентификаторе — слагу достаточно уникального идентификатора.

Но можно поступить умнее: что, если мы представим слаг как целочисленное поле с автоинкрементом? 
Нам просто нужно использовать нашу базовую функцию преобразования, чтобы преобразовать их в слаги! 
Это также дало бы нам легкое отслеживание нашего глобального current_random_slug_id — MySQL будет отслеживать самый высокий текущий идентификатор в таблице, 
когда он автоматически увеличивается. Однако будьте осторожны: созданные пользователями слаги затрудняют применение этой стратегией! 
Как вы можете поддерживать уникальность среди пользовательских и случайных слагов, не нарушая автоматически увеличивающиеся идентификаторы для случайно сгенерированных слагов?

Как еще мы можем ускорить чтение базы данных?
Мы можем держать в памяти как можно больше данных, чтобы не читать их с диска.

Это становится особенно важным, когда мы начинаем получать большое количество запросов по одной ссылке, например, 
если одна из наших ссылок находится на главной странице Reddit. Если у нас есть URL-адрес перенаправления прямо в памяти, 
мы можем быстро обработать эти перенаправления.

В зависимости от используемой базы данных она может уже иметь систему кэширования в памяти. Чтобы получить больше ссылок в памяти, 
мы можем настроить нашу базу данных так, чтобы она использовала больше места для кэша.

Если чтение по-прежнему медленное, мы могли бы изучить вопрос о добавлении слоя кэширования, такого как memcached. 
Важно отметить, что это может не сэкономить нам время на чтение, если кеш в базе данных уже достаточно надежен. 
Это добавляет сложности — теперь у нас есть два источника правды, и нам нужно следить за их синхронизацией. 
Например, если мы позволим пользователям редактировать свои ссылки, нам нужно отправить эти изменения как в базу данных, так и в кеш. 
Это также может замедлить чтение, если у нас много промахов кеша.

Если бы мы добавили слой кэширования, мы могли бы поговорить о нескольких вещах:
1. Стратегия выселения. Если кеш заполнен, что мы удаляем, чтобы освободить место? Наиболее распространенным ответом является стратегия LRU («наименее недавно использовавшаяся»).
2. Стратегия шардинга. Разделение нашего кеша позволяет нам хранить больше данных в памяти, потому что мы можем использовать больше машин. Но как мы решаем, какие вещи поместить в какой шард? Обычный ответ — «стратегия хэширования и модификации»: хэшируйте ключ, изменяйте результат на количество осколков, и вы получаете номер осколка, на который нужно отправить запрос. Но тогда как добавить или удалить сегмент, не вызывая неконтролируемого всплеска промахов кеша?

Следующим узким местом может быть обработка фактических веб-запросов. Чтобы исправить это, мы должны настроить несколько 
рабочих веб-серверов. Мы можем разместить их всех за балансировщиком нагрузки, который распределяет входящие запросы между рабочими процессами. 
Наличие нескольких веб-серверов усложняет нашу базу данных (и уровни кэширования), что нам необходимо учитывать. 
Например, им нужно будет обрабатывать больше одновременных подключений. Большинство баз данных довольно хорошо справляются с этим по умолчанию.

Хорошо, теперь наши перенаправления должны выполняться довольно быстро и должны быть устойчивыми к скачкам нагрузки. 
У нас есть надежная система, которая соответствует всем нашим целям дизайна!
1. Мы можем хранить много ссылок.
2. Наши короткие ссылки максимально короткие.
3. Переход по короткой ссылке — это быстро.
4. Сссылки устойчивы к скачкам нагрузки.

<b>Бонус вопросы:</b>
1. В какой-то момент мы, вероятно, захотим рассмотреть возможность разделения конечной точки создания ссылки между несколькими рабочими процессами. Это добавляет сложности: как они синхронизируются с тем, что такое current_random_slug_id?
2. Время безотказной работы и «единая точка отказа» (SPOF) являются общими проблемами при проектировании системы. Есть ли какие-либо SPOF в нашей текущей архитектуре? Как мы можем гарантировать, что сбой отдельной машины не приведет к выходу из строя всей нашей системы?
3. Аналитика. Что, если бы мы хотели показать пользователям некоторую аналитику о созданных ими ссылках? Какую аналитику мы можем показать и как мы будем ее хранить и отображать?
4. Редактирование и удаление. Как бы мы добавили функции редактирования и удаления?
5. Оптимизация времени реализации. Мы создали что-то оптимизированное для масштабирования. Как бы изменился дизайн нашей системы, если бы мы просто пытались создать MVP как можно быстрее?
