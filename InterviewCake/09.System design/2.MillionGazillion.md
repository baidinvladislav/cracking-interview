Рассмотрим ситуацию, мы написали парсер, который свободно посещает сайты в сети интернет.
Для того чтобы парсер не посещал один и тот же сайт дважды, мы выделили множество для хранения посещенных сайтов.
Через какое то время множество сайтов стало слишком велико, как оптимизировать затраты по памяти?

Оптимизация не должна навредить скорости работы.

Рассмотрим множество сайтов, каждый сайт наичнается 'www'.
Мы можем реализовать множество сайтов, как вложенный словарь, где внешний ключ - это поддомен, внутренний ключ - это
остальная часть URL. Например, visited['www.']['google.com'] = True и visited['www.']['interviewcake.com'] = True.

Теперь вместо сохранения «www.» для каждого из этих URL-адресов мы только что сохранили его один раз в памяти.
Если у нас хранится 1.000 адресов и половина из них начинается с «www.» тогда вместо сохранения 500x4 символов, 
мы сохраним в памяти только 4.

Но мы можем еще лучше.

Что если мы используем тот же подход выделения общего префикса рекурсивно?
Какой длины нам следует делать префиксы? Что если мы сделаем префиксы только лишь из одной буквы?

Мы можем использовать структуру данных Trie.

Представим множество посещенных сайтов, как вложенный словарь, где каждый словарь имеет только один символ.
Мы будет хранить 'google.com' как  visited['g']['o']['o']['g']['l']['e']['.']['c']['o']['m']['*'] = True
'*' в конце, значит конец URL. Иначе нам было бы сложно различать префиксы от полного сайта. В примере выше
'google.co'  - это префикс, который мы могли бы принять за посещенный URL-адрес, если бы у нас не было способа обозначить конец сайта.

Теперь, когда мы будем добавлять 'google.com/maps' в посещенные сайты, мы добавим только '/maps', потому как 'google.com'
уже находится там, тоже самое и с 'google.com/about/jobs'.

Мы можем представить это как дерево, где каждый символ в строке соответствует узлу. Три - это тип дерева.

Чтобы проверить, находится ли строка в дереве, мы просто спускаемся от корня дерева к листу, 
проверяя наличие узла в дереве, соответствующего каждому символу в строке.

Как мы можем реализовать такую структуру? Есть несколько способов.
Мы можем использовать: вложенные словари, узлы и указатели. Оценка плюсов и минусов различных вариантов 
и выбор одного из них — отличная вещь на собеседовании по программированию. 

В нашей реализации мы используем два вложенных словаря.
Чтобы определить, посещался ли данный сайт, мы просто вызываем add_word(), который добавляет слово в дерево, если его там еще нет.


```python
class Trie(object):

    def __init__(self):
        self.root_node = {}
    
    def add_word(self, word):
        current_node = self.root_node
        is_new_word = False
    
        # Work downwards through the trie, adding nodes
        # as needed, and keeping track of whether we add
        # any nodes.
        for char in word:
            if char not in current_node:
                is_new_word = True
                current_node[char] = {}
            current_node = current_node[char]
    
        # Explicitly mark the end of a word.
        # Otherwise, we might say a word is
        # present if it is a prefix of a different,
        # longer word that was added earlier.
        if "End Of Word" not in current_node:
            is_new_word = True
            current_node["End Of Word"] = {}
    
        return is_new_word

```

Также можно использовать троичное дерево поиска или фильтр Блума.

<b>Сложность</b>
