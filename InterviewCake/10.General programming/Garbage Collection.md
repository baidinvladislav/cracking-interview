<h2>Garbage Collection</h2>

Сборщик мусора автоматически освобождает память, которую программа больше не использует. 
Например, скажем, мы сделали это в Python 3.6:

```python
def get_min(nums):
    # Note: this is *not* the fastest way to get the min!
    nums_sorted = sorted(nums)
    return nums_sorted[0]

my_nums = [5, 3, 1, 4, 6]
print(get_min(my_nums))

```

Посмотрите на nums_sorted в get_min(). Мы размещаем весь этот список внутри нашей функции, 
и как только функция возвращается, нам больше не нужен этот список. На самом деле, как только функция возвращается, 
у нас больше нет ссылок на нее!

Что происходит с этим списком в памяти? Сборщик мусора Python 3.6 заметит, 
что он нам больше не нужен, и освободит это место.

Как сборщик мусора узнает, что что-то можно освободить?

Один из вариантов — начать с выяснения того, что мы не можем освободить. Например, 
мы определенно не можем освободить локальные переменные, которые нам понадобятся позже. И, если у нас есть список, 
то мы также не должны освобождать ни один из элементов списка.

Это основная стратегия сборщика мусора:
1. Выяснить, какие вещи в памяти мы все еще можем использовать или нуждаться в них позже.
2. Высвободить все остальное

Эту стратегию часто называют отслеживанием сборки мусора, так как мы обычно реализуем первый шаг, 
отслеживая ссылки от одного объекта (скажем, списка) к другому (элементу в списке).

Другой вариант заключается в том, чтобы каждый объект отслеживал количество вещей, которые на него ссылаются, например, 
переменная, содержащая местоположение массива или несколько ребер, указывающих на один и тот же узел в графе.

Мы называем это число счетчиком ссылок на объект. В этом случае сборщик мусора может освободить все, что имеет нулевой счетчик ссылок. 
Эта стратегия называется подсчетом ссылок, поскольку мы подсчитываем количество ссылок на каждый объект.

Некоторые языки, например C, не имеют сборщика мусора. Поэтому нам нужно вручную освободить любую память, 
которую мы выделили, как только мы закончим с ней.

Это называется ручным управлением памятью.

Некоторые языки, такие как C++, имеют как ручное, так и автоматическое управление памятью.
