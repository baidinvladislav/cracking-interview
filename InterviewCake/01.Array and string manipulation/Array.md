<h2>Обзор массива</h2>

Массив содержит элементы последовательно, один за другим в памяти. Каждая позиция в массиве имеет индекс, начиная с 0.

|        | Worst Case |
|--------|------------|
| space  | O(n)       |
| lookup | O(1)       |
| append | O(1)       |
| insert | O(n)       |
| delete | O(n)       |

Преимущества:
1. Быстрый доступ к элементу. Получение элемента по индексу за константное время, независимо от длины массива.
2. Быстрое добавление элемента в конец массива. Добавление элемент в конец массива константное время, при условии,
в массиве имеется свободная память

Недостатки:
1. Ограниченный размер. Нужно указать количество элементов, которые вы будете хранить в массиве при его создании. (прим. речь не про динамический массив)
2. Дорогие вставки и удаления. Сдвиги элементов для закрытия или создания займут O(n).


Некоторые языки программирования, например, Python не имеют массивов.
Но например статичные массивы есть в Java и C++.

<h2>Вставка</h2>
Если мы хотим вставить что то в массив, вначале нам создать пространство для элемента, сдвигая элементы на 1 ячейку с индекса
на который мы хотим вставить элемент.

```
Чтобы вставить D на 3 индекс
[A, B, C, --E, F, G-->...]

```

Худший случай, когда мы вставляем элемент на 0 индекс массива (prepending), тогда мы должны сдвинуть все элементы в массиве.
Это будет работать за O(n).

<h2>Удаление</h2>
Элементы массива хранятся послдовательно друг за другом. Так когда мы удаляем элемент мы должны заполнить пустой гэп,
"подтягивая" все элементы, которые были после удаленного элемента массива.

```
Чтобы удалить Q с 3 индекса
[A, B, C, xQx, <--E, F, G--...]

```

Худший случай, когда мы удаляем нулевой элемент массива, тогда нам нужно "подтянуть" все элементы массива к началу.
Это займет O(n) времения. Может возникнуть вопрос, почему бы нам не оствить гэпы в массиве? Ответ в том, 
что преимущество быстрого доступа к элементу по индексу требует того, чтобы все элементы хранились последовательно и непрерывно.
Это позволяет нам точно предсказать, как далеко от начала 138ой или 9413ый элемент. Если есть пробелы, мы больше не можем
точно предсказать, где будет находиться каждый элемент массива.

<h2>Структуры данных поверх массива</h2>
Массивы служат блоками для других структурах данных, если не хотите указать размер массива при создании, используйте динамический массив,
если хотите хранить в массиве не только индексы, используйте хэш-таблицу.
