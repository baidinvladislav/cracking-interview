<h2>Алгоритмы in-place</h2>

Алгоритмы in-place изменяют структуру данных за пределами собственного фрейма. Из-за этого изменения, сделанные функцией,
остаются после завершения вызова.

Алгоритмы in-place иногда называются деструктивными, поскольку изначальный инпут разрушается или
изменяется из-за вызова функции.

Будьте осторожнее: алгоритмы in-place, не означает "без создания дополнительных переменных"!
Скорее, это значит, "без создания новой копии инпута". Как правило, in-place ф-ия будет создавать только дополнительные
переменные, которые занимают O(1) пространства.

Функции out-of-place не делают никаких изменений, которые могут видеть другие ф-ии.
Обычно такие ф-ии копируют структуры данных прежде чем ими манипулировать или изменять их.

В большинстве языков программирования примитивы (числа, числа с плавающей запятой, символы) копируются, когда передаются в качестве
аргумента, а более сложные структуры данных, такие как списки, кучи, словари передаются по ссылке. 
Это то как работает Python.

Две этих ф-ии выполняют одну и ту же операцию, но в первом случае мы делаем in-place алгоритм, 
а во втором алгоритм out-of-place.

```python
def square_list_in_place(int_list):
    for index, element in enumerate(int_list):
        int_list[index] *= element
    
    # NOTE: no need to return anything - we modified
    # int_list in place


def square_list_out_of_place(int_list):
    # We allocate a new list with the length of the input list
    squared_list = [None] * len(int_list)

    for index, element in enumerate(int_list):
        squared_list[index] = element ** 2

    return squared_list

```

Использование in-place алгоритмов - это хороший способ сэкономить время и память.
Такие алгоритмы избегают затрат на инициализацую или копирования структур данных, поэтому обычно такие алгоритмы
работают за O(1) сложности по памяти.

Но будьте осторожны алгоритмы in-place имеют побочные эффекты. Инпут будет изменен, 
что может сказать на работе кода за пределами твоей функции.

Например:
```python
original_list = [2, 3, 4, 5]
square_list_in_place(original_list)

print("original list: %s" % original_list)
# Prints: original list: [4, 9, 16, 25], confusingly!

```

В основном, out-of-place алгоритмы считаются безопаснее, поскольку они избегают побочных эффектов.
Вам слудует использоватьь in-place алгоритм, если вы ограничены по памяти или вы уверены, что вам больше никогда
не понадобится изменяемый инпут, даже для отладки.
