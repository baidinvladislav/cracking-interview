<h2>Обзор динамического массива</h2>

Динамический массив это массив с большим улучшением: автоматическое увелечением размера.
Одним из ограничений массивов является то, что они ограниченного размера, это значит, что вам нужно
указать количество элементов, которые будет хранить массив, это делается при инициализации массива.

Динамический массив увеличивается по мере добавления в него элементов. Таким образом
нам больше не нужно указывать размер массива заранее.

|        | AverageCase | Worst Case |
|--------|-------------|------------|
| space  | O(n)        | O(n)       |
| lookup | O(1)        | O(1)       |
| append | O(1)        | O(n)       |
| insert | O(n)        | O(n)       |
| delete | O(n)        | O(n)       |

Преимущества:
1. Быстрый доступ к элементу. Также как и статичные массивы, получение элемента по его индекса, занимает О(1) времени. 
2. Изменяемый размер. Ты можешь добаивить так много элементов, сколько вам нужно, динамический массив будет увеличиваться, 
чтобы удержать все эти элементы.
3. Кэш-френдли. Также как и статичные массивы, динамические массивы размещают элементы рядом друг с другом в памяти,
что делает использование кэша эффективным.

Недостатки:
1. Медленные добавления в конец, в худшем случае. Обычно, добавление нового элемента в конец динамического массива 
занимает О(1) времени. Но если динамический массив не имеет свободной ячейки для нового элемента, то массиву необходимо
увеличиться, что займет О(n) для копирования всех элементов в новый массив.
2. Дорогие вставки (не в конец) и удаления. Также как и у статичных массивов, элементы в динамических массивах хранятся
непрерывно друг от друга. Так что добавление или удаление элемента из центра массива потребует сдвига других элементов,
что займет О(n) времени.

В Python динамические массивы называются списки (list).
```python
gas_prices = []

gas_prices.append(346)
gas_prices.append(360)
gas_prices.append(354)
```

<h2>Размер и вместимость</h2>
Когда вы аллоцируете динамический массив, ваша реализация динамического массива создает базовый массив
фикисрованного размера. Начальный размер зависит от реализации, допустим наша реализация использует 10 индексов.
Теперь добавим в массив 4 элемента в наш динамический массив. Теперь наш массив имеет длину 4. Но базовый массив также
имеет длину 10.

Мы можем сказать, что теперь наш массив имеет размер (size) 4 и вместимость (capacity) 10. Динамический массив
хранит индекс последнего элемента, для того чтобы отслеживать где динамический массив заканчивается и начинается 
использование экстра памяти. 

<h2>Удвоение добавлений в конец</h2>
Что если мы пытаемся добавить новый элемент в массив, но его емкость уже заполнена?
Чтобы сделать новую ячейку, динамический массив автоматически делает новый базовый массив, обычно в два раза больше.

Почему бы нам просто не расширить текущий массив? Потому что слоты в памяти могут быть заняты другими программами.
Каждый элемент старого массива будет по одному скопирован в новый массив.
Копирование каждого элемента занимает О(n) времени! Поэтому всякий раз, 
когда добавление элемента в динамический массив заставляет нас создавать нвоый базовый массив двойного размера, 
это добавление занимает О(n) времени.

Это худший случай. Но лучший случай (а также и средний случай) добавления элемента в конец динамического массива
работает за О(1) времени.

<h2>Амортизированная стоимость добавлений в конец</h2>
1. Стоимость каждого "двойного добавления" увеличивает сложность для работы с таким массивом.
2. В тоже время количество вставок в конец работающее за О(1) снижает общие затраты для работы с таким массивом.

Эти две вещи как бы «уравновешиваются», и мы можем сказать, что каждое добавление имеет среднюю стоимость 
или амортизированную стоимость равную О(1).

Учитывая это, в индустрии мы обычно говорим, что динамические массивы имеют затраты на добавление элемента в конец O(1),
хотя строго говоря, это верно только для среднего случая или для амортизированной стоимости.
