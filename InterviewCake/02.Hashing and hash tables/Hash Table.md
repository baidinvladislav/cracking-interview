<h2>Обзор хэш-таблицы</h2>

Хэш-таблица упорядычивает данные, для быстрого доступа к элементу по ключу.

|        | Worst Case |
|--------|------------|
| space  | O(n)       |
| lookup | O(1)       |
| append | O(1)       |
| insert | O(n)       |
| delete | O(n)       |

Преимущества:
1. Быстрый доступ к элементу. Получение элемента по ключу за О(1) в среднем случае.
2. Гибкие ключи. Большинство типов данных могут быть ключами в хэш-таблице, главное, чтобы они были хэшируемыми.

Недостатки:
1. Медленный доступ к элементу в худшем случае. Доступ займет O(n) в худшем случае.
2. Нет сортировки. Ключи не отсортированы в определенном порядке. Если нам понадобится найти самый маленький,
или самый большой элемент в таблице, то нам нужно будет пройти по всем элементам за О(n).
3. Одно-направленный доступ к данным. В то время как доступ к элементу по ключу в среднем случае реализован за О(1),
доступ к ключу по значению требует прохода по всем элемента таблицы опять же за О(n).
4. Не кэш-френдли. Многие реализации хэш-таблиц используют связный список, которые не хранят данные в соседних ячейках памяти.

<h2>Хэш-таблицы построены над массивом</h2>
Массивы очень похожи на хэш-таблицы. Массив позволяет быстро получить элемент по "ключу" ньюанс только в том,
что мы не можем выбирать "ключи" - они всегда будут представлены индексами массива. Хэш-таблица позволяет выбрать ключи
и использовать в качестве ключей не только индексы. Все что для этого нужно - это хэш функция, которая переведет 
значение ключа в индекс массива, по которому мы потом получим значение ключа.

Чтобы получить элемент мы возьмем ключ, передадим его нашей хэш-функции, получим хэш, который будет являться индексом в нашем массиве.

<h2>Когда операции хэш-таблицы стоят О(n)?</h2>
1. Хэш-коллизии. Если все нащи ключи вызовут хэш-коллизии, то мы бы получили доступ к элементу за О(n),
проходя по одному большому связному списку. Это худший случай.
2. Динамическое увеличение размера. Предположим, что мы добавляем все больше и больше элементов в таблицу. Поскольку количество
ключей и значений в хэш таблице превысит количество индексов в базовом массиве, коллизии становятся неизбежными.
Чтобы предотвратить это, мы можем увеличивать базовый массив, всякий раз, когда памяти недостаточно. Это потребует
выделние бОльшего массива и повторного хэширования всех наших ключей, чтобы заново разместить данные в массиве за О(n).

<h2>Множества</h2>
Множества - это как словари, но они хранят только ключи, без значений.

Множества часто используются, когда нужно отследить группу элементов - узлы, которые мы уже посители в графе,
символы в строке, которые мы уже видели, цвета используемые соседними вершинами. Обычно нас интересует есть ли что либо 
в множестве или нет. В Python множества реализованы похожим со словарем образом.
