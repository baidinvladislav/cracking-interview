Когда вы создаете целочисленную переменную, ваш компьютер выделяет фиксированное количество битов для ее хранения. 
Большинство современных компьютеров используют 32 или 64 бита. Но некоторые числа настолько велики, 
что не помещаются даже в 64 бита, например секстиллион (миллиард триллионов), что составляет 70 цифр в двоичном формате.

Иногда у нас может быть число, которое умещается в 32 или 64 бита, но если мы добавим к нему 
(или умножим на что-то, или проделаем другую операцию), результат может не уместиться в исходные 32 или 64 бита. 
Это называется целочисленным переполнением.

Например, предположим, что у нас есть всего 2 бита для хранения целых чисел. 
Таким образом, мы можем хранить только беззнаковые (неотрицательные) целые числа 0-3 в двоичном виде:

```python
# 00 (0)
# 01 (1)
# 10 (2)
# 11 (3)

```

Что произойдет, если у нас есть 3 (11) и мы попытаемся добавить 1 (01)? Ответ 4 (100), 
но для этого требуется 3 бита, а у нас только 2.

Дальнейшие действия зависят от языка:
* Некоторые языки, такие как Python или Ruby, замечают, что результат не подходит, и автоматически выделяют место для большего числа.
* В других языках, таких как C или Java, процессор как бы «делает все возможное» с имеющимися у него битами, 
беря истинный результат и отбрасывая любые биты, которые не подходят. Таким образом, 
в нашем примере выше при добавлении 01 к 11 процессор возьмет истинный результат 100 и отбросит самый старший бит, оставив 00.
* Swift выдаст ошибку, если целое число переполняется, если вы явно не указали, что переполняющие целые числа должны быть усечены, 
чтобы соответствовать (например, в C или Java).

В языках, в которых возможно целочисленное переполнение, вы можете уменьшить его вероятность, 
используя более крупные целочисленные типы. Например, long long int в C или long в Java. 
Если вам нужно хранить что-то еще большее, существуют библиотеки, созданные для обработки произвольно больших чисел.

В некоторых языках вы также можете воспользоваться функциями проверки переполнения, 
предоставляемыми компилятором или интерпретатором.
