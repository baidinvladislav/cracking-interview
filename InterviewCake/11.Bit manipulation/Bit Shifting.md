Битовый сдвиг перемещает каждую цифру в двоичном представлении числа влево или вправо. 
Различают три основных вида смен:

1. Левые сдвиги
При сдвиге влево наиболее значимый бит теряется, а на другом конце вставляется бит 0.

Оператор сдвига влево обычно записывается как «<<».

```python
# 0010 << 1  →  0100
# 0010 << 2  →  1000

```

Одиночный сдвиг влево умножает двоичное число на 2:
```python
# 0010 << 1  →  0100
# 
# 0010 is 2
# 0100 is 4

```

2. Логический сдвиги вправо
При сдвиге вправо с логическим сдвигом вправо младший бит теряется, а на другом конце вставляется 0.

```python
# 1011 >> 1  →  0101
# 1011 >> 3  →  0001

```

Для положительных чисел один логический сдвиг вправо делит число на 2, отбрасывая все остатки.

```python
# 0101 >> 1  →  0010
# 
# 0101 is 5
# 0010 is 2

```

3. Арифметические сдвиги вправо
При сдвиге вправо с помощью арифметического сдвига вправо наименее значащий бит теряется, 
а старший значащий бит копируется.

Языки обрабатывают арифметические и логические сдвиги вправо по-разному. 
Оператор сдвига вправо Python (>>) всегда выполняет арифметический сдвиг вправо.

```python
# 1011 >> 1  →  1101
# 1011 >> 3  →  1111
# 
# 0011 >> 1  →  0001
# 0011 >> 2  →  0000

```

Первые два числа имели 1 в качестве старшего бита, поэтому во время сдвига было вставлено больше 1. 
Последние два числа имели 0 в качестве старшего бита, поэтому сдвиг вставил больше 0.

Если число закодировано с использованием дополнения до двух, то арифметический сдвиг вправо сохраняет знак числа, 
а логический сдвиг вправо делает число положительным.

```python
# Arithmetic shift
# 1011 >> 1  →  1101
#     1011 is -5
#     1101 is -3

# Logical shift
# (Not a thing in Python, but if it were :)
# 1111 >> 1  →  0111
#     1111 is -1
#     0111 is  7

```
