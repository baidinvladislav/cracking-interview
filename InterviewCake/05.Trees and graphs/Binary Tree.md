<h2>Бинарное дерево</h2>

Бинарное дерево - это дерево, в котором каждый узел имеет 2 и менее узлов. Дети обычно называются 
левый и правый.

````python
class BinaryTreeNode(object):

    def __init__(self, value):
        self.value = value
        self.left  = None
        self.right = None

````

Если каждый узел бинарного дерева имеет 2 узла, так такое дерево называется "полным бинраным деревом".
Полные бинарные деревья имеют несколько отличительных особенностей:
1. Общее количество узлов на каждом «уровне» удваивается по мере продвижения вниз по дереву.
2. Количество узлов на последнем уровне равно сумме количеству узлов на всех остальных уровнях + 1.
Другими словами около половины наших узлов находятся на последнем уровне.

Обычно количество узлов дерева обозначают как n, а высоту как h. h также можно рассматривать как кол-во
уровней.

Если нам известно h, как мы можем вычислить n?
Просто сложим кол-во узлов на каждом уровне. Как много у нас уровне?

Количество узлов будет равняться как 2 в степени числа, которое берется от уровня. Уровни отсчитываются от 0.

Например:
1. Уровень 0: 2^0 = 1
2. Уровень 1: 2^1 = 2
3. Уровень 2: 2^2 = 4
4. Уровень 3: 2^3 = 8
5. etc

Так что итоговое количество узлов в полном бинарном дереве равно:
n = 2^0 + 2^1 + 2^2 + 2^3 + ... + 2^h - 1

Откуда берется h - 1, а не h? Так как мы начинаем отсчет с 0, то наш последний уровень будет как раз n - 1. 

Можно представить формулу для n иначе. Второе свойство нам говорит, что кол-во узлов на последнем уровне
на 1 больше чем половина узлов всего дерева, так что мы можем просто взять количество узлов на последнем уровне,
умножить на 2 и вычесть 1, чтобы получить общее количество узлов в дереве. Мы знаем, что кол-во узлов
на последнем уровне 2^h - 1, так что:
n = 2^h-1 * 2 - 1
n = 2^h-1 * 2^1 - 1
n = 2^h-1+1 - 1

Так мы можем выразить n через h. Как насчет обратного направления? Мы можем посчитать через логорифм:

n = 2^h - 1
n + 1 = 2^h
log2(n + 1) = log2(2^h)
log2(n + 1) = h
