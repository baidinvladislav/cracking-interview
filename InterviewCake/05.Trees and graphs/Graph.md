<h2>Граф</h2>

Граф организует элементы во взаимосвязанной сети.

Каждый элемент - это узел (или вершина). Узлы соединены ребрами.

Сильная сторона:
* Представление связей

Слабая сторона:
* Проблемы масштабирования. Большинство алгоритмов работают за O(n * lg(n)) или даже медленее.
В зависимости от размера вашего графа, запуск алгоритмов между узлами может оказаться неосуществим.

Графы делятся на:

* "ориентированные" или "неориентирвоанные"
В ориентированные графе, ребра указывают от одного узла к другому узлу.
В неориентированном графе ребра просто соединяют узлы на каждом конце.

* "циклические" или "ациклические" 
Граф циклический, если в нем содержится цикл - непрерывный ряд узлов, 
который соединяется сам с собой. Граф без циклов называется ациклический.

* "взвешенные" или "невзвешенные"
Если граф взвешенный, каждое ребро имеет "вес". Вес, например, может представлять дистанцию 
между двумя городами, также цену билета или расстояние между городами.

Раскраска графов
Это когда дается цвет каждой вершине графа. Ни смежная друг с другом вершина графа не должна иметь одинаковый цвет.

Представляются графы несколькими способами:
* список ребер:
```python
graph = [[0, 1], [1, 2], [1, 3], [2, 3]]
```
Посколько в этом примере, все узлы графа связаны друг с другом все они есть в списке, 
но данный способ не отобразит вершину, если она не связана ни с одним узлом графа.

* список смежности:
Список, где каждый индекс представляет узел, используя список, в списке перечислены связанные с узлом узлы.
```python
graph = [
    [1],
    [0, 2, 3],
    [1, 3],
    [1, 2]
]
```

Мы также может использовать словарь, где ключи представляют узел, а значения это список связанных узлов.
```python
graph = {
    0: [1],
    1: [0, 2, 3],
    2: [1, 3],
    3: [1, 2]
}
```
Это полезно, если узлы представляны строками, объектами или чем либо еще, что не очевидно можно подвязать к индексам.

* матрица смежности
Матрица 0 и 1, которая выражает отношения узлов в булевом формате

```python
graph = [
    [0, 1, 0, 0],
    [1, 0, 1, 1],
    [0, 1, 0, 1],
    [0, 1, 1, 0]
]
```

Поскольку в нашем примере узел 3 имеет ребра к 1 и 2 узлам в этих ячейках отображается 1.


<h4>Алгоритмы</h4>

Существуют два обхода по графам и деревьям BFS и DFS, большниство задач на эти структуры данных решаются этими алгоритмами.

Например:
* существует ли путь между двумя узлами в неориентированным графе? Запустите BFS или DFS от одной вершины и посмотрите достигнете
ли вы другой вершины
* какой самый короткий путь в между двумя вершинами в неориентированном, невзвешенном графе? Запустите BFS от одной вершины
к другой и вернитесь (backtrack) как только достигнете вторую вершину. Обратите внимание, что BFS всегда находит самый короткий
путь между двумя вершинами, в то время как DFS не всегда находит кратчайчий путь.
* может ли граф быть раскрашен двумя цветами? Запустить BFS, присваивая цвета всем вершинами, которые мы посетили.
Прервать алгоритм, если мы попытаемся присвоить узлу цвет, отличный от того, который был ранее.
* имеет ли ненправленный граф цикл? Запустите BFS, отслеживая количество раз, когда мы видели каждую вершину.
Если мы посещаем одну вершину дважды, то значит, граф имеет цикл.

<h4>Продвинутые алгоритмы графов</h4>
* алгоритм Дейкстры. находит кратчайший путь от одной вершины до всех остальных вершин в взвешенном графе.
* топологическая сортировка. упорядочивает узлы направленного ациклического графа в особом порядке на основе входящих ребер.
* минимальное остовое дерево. находит самый дешевый набор ребер, необходимый для достижения всех узлов взвешенного графа.
