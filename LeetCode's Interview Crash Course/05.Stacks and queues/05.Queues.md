## Queues

While a stack followed a LIFO pattern, a queue follows FIFO (first in first out). In a stack, elements are added 
and removed from the same side. In a queue, elements are added and removed from opposite sides. Like with a stack, 
there are multiple ways to implement a queue, but the important thing that defines it is the abstract interface of adding 
and removing from opposite sides.

An example of a queue in the physical world is a line at a fast food restaurant. People leave the line 
when they finish ordering (from the front) and people enter the line from the back (opposite ends). The first people 
to enter the line will be the first ones that leave it (FIFO). An example of a queue in the practical software world 
would be any system that handles a job on a first come, first serve basis - for example, 
if multiple people are trying to use a printer at the same time.

Queues are trickier to implement than stacks if you want to maintain good performance. Like a stack, 
you could just use a dynamic array, but operations on the front of the array (adding or removal) are O(n), 
where n is the size of the array. Adding to a queue is called enqueue and deletions are called dequeue. 
If you want these operations to be O(1), you'll need a more sophisticated implementation.

One way to implement an efficient queue is by using a doubly linked list. Recall that with a doubly linked list, 
if you have the pointer to a node, you can add or delete at that location in O(1). A doubly linked list 
that maintains pointers to the head and tail (both ends, usually with sentinel nodes) can implement an efficient queue.

There is also a data structure called a deque, short for double-ended queue, and pronounced "deck". In a deque, 
you can add or delete elements from both ends. A normal queue designates adding to one end and deleting to another end.

For algorithm problems, queues are less common than stacks, and the problems are generally more difficult. 
The most common use of a queue is to implement an algorithm called breadth-first search (BFS), 
which we will learn about in a future chapter. Outside of BFS, unlike stack, there aren't many problems 
whose main focus is a queue - we'll still look at a few examples, but keep in mind 
that a queue is mostly used to implement BFS.


```python
# Declaration: we will use deque from the collections module
import collections
queue = collections.deque()

# If you want to initialize it with some initial values:
queue = collections.deque([1, 2, 3])

# Enqueueing/adding elements:
queue.append(4)
queue.append(5)

# Dequeuing/removing elements:
queue.popleft() # 1
queue.popleft() # 2

# Check element at front of queue (next element to be removed)
queue[0] # 3

# Get size
len(queue) # 3
```

<h3>Example: 933. Number of Recent Calls</h3>
Implement the RecentCounter class. It should support ping(int t), which records a call at time t, 
and then returns an integer representing the number of calls that have happened in the range [t - 3000, t]. 
Calls to ping will have increasing t.

We have a stream of increasing integers, and every time we add an integer to the stream, 
we need to find how many numbers are in the stream within 3000. The brute force method would be 
to put all the integers in an array, and iterate over the array each time to count how many integers are within 3000. 
This would be very inefficient - let's say we have a value x. Once t goes beyond x + 3000, 
every future call to ping would have to iterate over x, even though we already know that x won't be included. 
We should get rid of x as soon as it is outdated.

To do this with a dynamic array, we could just remove values less than t - 3000 from the front. However, 
this is still inefficient because removing from the front of an array is O(n), where n is the size of the array. 
If we use an efficient queue instead, then those removals become O(1)! Let's use a queue to store the numbers, 
and at each call to t remove all the outdated elements before returning the count.

Our goal is to have a queue hold all calls that have happened in the last 3000 units of time.

Because the calls come with increasing t, when we add timestamps to our queue, it will be in sorted order. 
This means the first element will always be the oldest call.

When we find that the oldest call happened more than 3000 ago, we maintain the queue by removing it.

After removing old calls, the length of the queue is the answer.

```python
from collections import deque

class RecentCounter:
    def __init__(self):
        self.queue = deque()

    def ping(self, t: int) -> int:
        while self.queue and self.queue[0] < t - 3000:
            self.queue.popleft()
        
        self.queue.append(t)
        return len(self.queue)


# Your RecentCounter object will be instantiated and called as such:
# obj = RecentCounter()
# param_1 = obj.ping(t)
```

In Python, we're using collections.deque to implement the queue. This data structure allows us 
to perform dequeue operations from the front in O(1).

There aren't a lot of problems where a queue shines on its own, which is why this article is lackluster. 
Don't worry though, in the trees & graphs chapter, you'll see how queues are used 
to implement BFS - an extremely powerful algorithm.

The next pattern, monotonic, applies to both stacks and queues. We'll look at a few more queue problems there.
