<h1>Введение в О большое</h1>

Нотация большого О используется, чтобы описать вычислительную сложность алгоритма.
Вычислительная сложность разделена на две части: временная и пространственная.
Временная сложность - это количество времени необходимое алгоритму для работы 
относительно размера входных данных. Пространственная сложность алгоритма - это 
количество памяти, выделяемое алгоритмом при запуске, по отношению к размеру входных данных.

<h2>Как работает сложность</h2>
Сложность описывается функцией. Какими должны быть аргументы этой функции?
Аргументы определяются программистом, но они должны покрывать все соответсвующие переменные,
которые будут изменяться, когда изменяются входные данные. Самая распространенная переменная
n, которая обычно обозначет длину входного массива или строки.

В контексте интервью мы делаем некоторые общие предположения. Например: при работе с целыми числами, 
чем больше значение, тем больше времени займут такие операции, как сложение, умножение или печать в консоль. 
Хотя это важно в теории, мы обычно игнорируем этот факт, потому что на практике разница очень мала. 
Если вам дан массив целых чисел в качестве входных данных, единственная переменная, которую вы будете использовать, 
это n для обозначения длины массива. Технически вы могли бы ввести другую переменную, скажем k, 
который обозначает среднее значение целых чисел в массиве. Однако этого никто не делает.

При написании функция оборачивается заглавной буквой O. 
Вот несколько примеров сложностей:
* O(n)
* O(n^2)
* O(2^n)
* O(log n)
* O(n * m)

<h2>Правила</h2>
Эти функции описывают, как количество операций/памяти, необходимых алгоритму, растет по мере того, 
как аргументы стремятся к бесконечности. Так как переменные стремятся к бесконечности, константы всегда игнорируются.
Это значит, что:
```
O(9999999n) = O(8n) = O(n) = O(n/500)
```

На чем мы хотим сосредоточиться, так это на том, как алгоритм масштабируется с размером входных данных.
Например, у нас есть два алгоритма. Один работает по времени за O(100n, а второй за O(5n).
Если мы удвоем n вдвое, то оба алгоритма будут работать дольше независимо от коэффицентов.
Таким образом оба алгоритма работают за O(n), хотя второй алгоритм в 20 раз быстрее, так как в обоих алгоритмах
сложность растет линейно с ростом n.

Это также означает, что при сложении/вычитании членов одной и той же переменной некоторые члены можно игнорировать.
Например, O(2^n + n^2 − 500n) = O(2n), потому как n стремится к бесконечности, 2^n намного превосходит
остальные два значения. 

Наилучшая возможная сложность - O(1), называемое «постоянное время» или «постоянное пространство». Это означает, 
что алгоритм ВСЕГДА использует одно и то же количество ресурсов, независимо от входных данных.

Обратите внимание, что постоянная временная сложность не обязательно означает, что алгоритм быстрый O(5000000) = O(1),
это просто означает, что время его выполнения не зависит от размера ввода.

Говоря о сложности, обычно выделяют три случая:
* Лучший случай
* Средний случай
* Худший случай

В большинстве алгоритмов все три из них будут равны, но в некоторых алгоритмах они будут отличаться.
Если вам нужно выбрать только один вариант для представления временной или пространственной сложности алгоритма, 
никогда не выбирайте наилучший сценарий. Правильнее всего использовать наихудший сценарий, 
но вы должны уметь говорить о разнице между случаями. 

<h2>Анализ временной сложности</h2>
Давайте рассмотрим несколько примеров алгоритмов в псевдокоде и поговорим об их временной сложности.
```
// Given an integer array "arr" with length n,

for (int num: arr) {
    print(num)
}
```
Этот алгоритм имеет временную сложность O(n). На каждой итерации, мы печатаем элемент, что стоит нам O(1).
Всего у нас n итераций, что дает нам итоговую временную сложность, как O(1⋅n) = O(n).

```
// Given an integer array "arr" with length n,

for (int num: arr) {
    for (int i = 0; i < 500,000; i++) {
        print(num)
    }
}
```
Этот алгоритм тоже имеет сложность O(n). На каждой итерации внутреннего цикла мы печатаем элемент,
что стоит нам опять же O(1). Этот цикл состоит из 500.000 итераций, что в итоге нам дает сложность O(500000) = O(1).
Внешний цикл имеет n итераций, что дает нам O(n).

Хотя технически оба алгоритма имеют одинаковую временную сложность, на самом деле второй алгоритм намного медленее
чем первый. Правильно сказать, что временная сложность O(n), но важно уметь обсуждать различия между практикой и теорией.

```
// Given an integer array "arr" with length n,

for (int num: arr) {
    for (int num2: arr) {
        print(num * num2)
    }
}
```
Этот алгоритм имеет временную сложность O(n^2). На каждой итерации внутреннего цикла мы выполняем умножение и печатаем результат,
что стоит нам O(1). Внутренний цикл имеет n итераций, что значит, что затраты на одну итерацию внешнего цикла O(n).
Внешний цикл имеет тоже n итераций, что в итоге дает нам временную сложность всего алгоритма O(n * n) = O(n^2).

```
// Given integer arrays "arr" with length n and "arr2" with length m,

for (int num: arr) {
    print(num)
}

for (int num: arr) {
    print(num)
}

for (int num: arr2) {
    print(num)
}
```
Временная сложность этого алгоритма O(n + m). Первые два цикла имеют сложность O(n),
когда последний цикл имеет сложность O(m). В результате получаем итоговую сложность, как O(2n + m) = O(n +m).

```
// Given an integer array "arr" with length n,

for (int i = 0; i < arr.length; i++) {
    for (int j = i; j < arr.length; j++) {
        print(arr[i] + arr[j])
    }
}
```
Этот алгоритм работает за O(n^2). Внутренний цикл for зависит от того, 
на какой итерации в данный момент находится внешний цикл for. При первом запуске внутреннего цикла for он запускается n раз.
Второй раз n - 1 раз, затем n - 2, n - 3 и так далее. Это означает, что общее количество итераций равно 1 + 2 + 3 + 4 + ... + n,
что является частичной суммой этого ряда. 

<h3>Логарифмическая сложность</h3>
Логарифм — это операция, обратная к показателям степени. Временная сложность O(logn) называется логарифмическим временем
и она очень быстрая. Общая временная сложность O(n logn), что является достаточно быстрым для большинства задач, 
а также временной сложностью эффективных алгоритмов сортировки.

Обычно основание логарифма равно 2. Это означает, что если ваш ввод имеет размер n,
то алгоритм выполнит x операций, где 2^x = n. Однако основание логарифма на самом деле не имеет значения для большого O, 
поскольку все логарифмы связаны постоянным коэффициентом.

O(log n) означает, что где-то в вашем алгоритме входные данные уменьшаются на процент на каждом шаге. 
Хорошим примером этого является бинарный поиск, алгоритм поиска, работающий за O(logn) время. 
При бинарном поиске мы изначально рассматриваем весь ввод (n элементов). После первого шага мы рассматриваем только n/2 элементов. 
После второго шага мы рассматриваем только n/4 элементов и так далее. На каждом шаге мы уменьшаем наше пространство поиска на 50%, 
что дает нам логарифмическую временную сложность.

<h2>Анализ пространственной сложности</h2>
Когда вы инициализируете переменные, такие как массивы или строки, ваш алгоритм выделяет память.
Мы никогда не учитываем пространство, занимаемое вводом (изменение ввода — плохая практика), и обычно не учитываем пространство, 
занимаемое выводом (ответом), если интервьюер не попросит нас об этом.

В приведенных ниже примерах код выделяет память только для того, чтобы мы могли анализировать сложность пространства, 
поэтому мы будем рассматривать все, что мы выделяем, как часть сложности пространства.

```
// Given an integer array "arr" with length n

for (int num: arr) {
    print(num)
}
```
Этот алгоритм имеет пространственную сложность O(1). Единственная переменная, 
которую мы выделяем здесь, это num, которая постоянна относительно n.

```
// Given an integer array "arr" with length n

Array doubledNums = int[]

for (int num: arr) {
    doubledNums.add(num * 2)
}
```
Этот алгоритм имеет пространственную сложность O(n), мы инициализируем массив doubledNums,
который линейно зависит от размера инпута.

```
// Given an integer array "arr" with length n

Array nums = int[]
int oneHundredth = n / 100

for (int i = 0; i < oneHundredth; i++) {
    nums.add(arr[i])
}
```
Этот алгоритм имеет пространственную сложность O(n). Массив nums хранит 1% от массива arr.
Это дает нам итоговую пространственную сложность O(n/100) = O(n).

```
// Given integer arrays "arr" with length n and "arr2" with length m,

Array grid = int[n][m]

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr2.length; j++) {
        grid[i][j] = arr[i] * arr2[j]
    }
}
```
Этот алгоритм имеет пространственную сложность O(n * m). Мы создаем сетку grid,
которая имеет размеры n * m.

